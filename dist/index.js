(()=>{var e,t,n,r,o,a,i={},s={};function l(e){var t=s[e];if(void 0!==t)return t.exports;var n=s[e]={id:e,exports:{}};return i[e](n,n.exports,l),n.exports}l.m=i,e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",t="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",n="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",r=e=>{e&&e.d<1&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},l.a=(o,a,i)=>{var s;i&&((s=[]).d=-1);var l,c,u,g=new Set,m=o.exports,p=new Promise(((e,t)=>{u=t,c=e}));p[t]=m,p[e]=e=>(s&&e(s),g.forEach(e),p.catch((e=>{}))),o.exports=p,a((o=>{var a;l=(o=>o.map((o=>{if(null!==o&&"object"==typeof o){if(o[e])return o;if(o.then){var a=[];a.d=0,o.then((e=>{i[t]=e,r(a)}),(e=>{i[n]=e,r(a)}));var i={};return i[e]=e=>e(a),i}}var s={};return s[e]=e=>{},s[t]=o,s})))(o);var i=()=>l.map((e=>{if(e[n])throw e[n];return e[t]})),c=new Promise((t=>{(a=()=>t(i)).r=0;var n=e=>e!==s&&!g.has(e)&&(g.add(e),e&&!e.d&&(a.r++,e.push(a)));l.map((t=>t[e](n)))}));return a.r?c:i()}),(e=>(e?u(p[n]=e):c(m),r(s)))),s&&s.d<0&&(s.d=0)},l.d=(e,t)=>{for(var n in t)l.o(t,n)&&!l.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},l.f={},l.e=e=>Promise.all(Object.keys(l.f).reduce(((t,n)=>(l.f[n](e,t),t)),[])),l.u=e=>e+".index.js",l.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),l.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),o={},a="image-effect:",l.l=(e,t,n,r)=>{if(o[e])o[e].push(t);else{var i,s;if(void 0!==n)for(var c=document.getElementsByTagName("script"),u=0;u<c.length;u++){var g=c[u];if(g.getAttribute("src")==e||g.getAttribute("data-webpack")==a+n){i=g;break}}i||(s=!0,(i=document.createElement("script")).charset="utf-8",i.timeout=120,l.nc&&i.setAttribute("nonce",l.nc),i.setAttribute("data-webpack",a+n),i.src=e),o[e]=[t];var m=(t,n)=>{i.onerror=i.onload=null,clearTimeout(p);var r=o[e];if(delete o[e],i.parentNode&&i.parentNode.removeChild(i),r&&r.forEach((e=>e(n))),t)return t(n)},p=setTimeout(m.bind(null,void 0,{type:"timeout",target:i}),12e4);i.onerror=m.bind(null,i.onerror),i.onload=m.bind(null,i.onload),s&&document.head.appendChild(i)}},l.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},l.v=(e,t,n,r)=>{var o=fetch(l.p+""+n+".module.wasm"),a=()=>o.then((e=>e.arrayBuffer())).then((e=>WebAssembly.instantiate(e,r))).then((t=>Object.assign(e,t.instance.exports)));return o.then((t=>"function"==typeof WebAssembly.instantiateStreaming?WebAssembly.instantiateStreaming(t,r).then((t=>Object.assign(e,t.instance.exports)),(e=>{if("application/wasm"!==t.headers.get("Content-Type"))return console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",e),a();throw e})):a()))},(()=>{var e;l.g.importScripts&&(e=l.g.location+"");var t=l.g.document;if(!e&&t&&(t.currentScript&&"SCRIPT"===t.currentScript.tagName.toUpperCase()&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");if(n.length)for(var r=n.length-1;r>-1&&(!e||!/^http(s?):/.test(e));)e=n[r--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),l.p=e})(),(()=>{var e={792:0};l.f.j=(t,n)=>{var r=l.o(e,t)?e[t]:void 0;if(0!==r)if(r)n.push(r[2]);else{var o=new Promise(((n,o)=>r=e[t]=[n,o]));n.push(r[2]=o);var a=l.p+l.u(t),i=new Error;l.l(a,(n=>{if(l.o(e,t)&&(0!==(r=e[t])&&(e[t]=void 0),r)){var o=n&&("load"===n.type?"missing":n.type),a=n&&n.target&&n.target.src;i.message="Loading chunk "+t+" failed.\n("+o+": "+a+")",i.name="ChunkLoadError",i.type=o,i.request=a,r[1](i)}}),"chunk-"+t,t)}};var t=(t,n)=>{var r,o,[a,i,s]=n,c=0;if(a.some((t=>0!==e[t]))){for(r in i)l.o(i,r)&&(l.m[r]=i[r]);s&&s(l)}for(t&&t(n);c<a.length;c++)o=a[c],l.o(e,o)&&e[o]&&e[o][0](),e[o]=0},n=self.webpackChunkimage_effect=self.webpackChunkimage_effect||[];n.forEach(t.bind(null,0)),n.push=t.bind(null,n.push.bind(n))})(),async function(){let e=null;try{e=await l.e(605).then(l.bind(l,605))}catch(e){return void console.error(e)}console.log(e);const t=document.getElementById("upload"),n=new FileReader;n.onloadend=()=>{let r=n.result.replace(/^data:image\/(png|jpeg|jpg);base64,/,"");console.log(t.files[0]);let o=function(){const e=document.getElementsByName("options");for(let t=0;t<e.length;t++)if(e[t].checked){const n=e[t].value;return console.log("Selected value: "+n),n}return console.log("No option selected"),null}(),a=e.augmentation(r,o);document.getElementById("original-img").setAttribute("src",n.result),document.getElementById("new-img").setAttribute("src",a),document.getElementById("original-img-caption").textContent="Original",document.getElementById("new-img-caption").textContent="Augmented",document.getElementById("explanation").textContent=function(e){switch(e){case"grayscale":return"Grayscale conversion removes all color information from the image, leaving only shades of gray. This can be useful in situations where color is not important, reducing the complexity of the data and focusing on texture and intensity patterns.";case"blur":return"Blurring an image reduces the sharpness and detail by averaging pixel values in a neighborhood. This can help simulate out-of-focus effects or reduce noise, making the model more robust to different focus conditions.";case"fliph":return"Horizontal flip (fliph) mirrors the image along the vertical axis, creating a left-to-right flipped version. This augmentation helps the model generalize to mirror images and handle situations where objects can appear on either side of the image.";case"flipv":return"Vertical flip (flipv) mirrors the image along the horizontal axis, creating an upside-down version. This can be useful for augmenting datasets where objects might appear in different orientations, such as in aerial or satellite imagery.";case"huerotate":return"Hue rotation shifts the colors in the image by rotating the hue values in the color space. This augmentation can simulate different lighting conditions or color variations, making the model more resilient to changes in color.";case"rotate90":return"A 90-degree rotation rotates the image by 90 degrees clockwise or counterclockwise. This augmentation helps the model handle objects in different orientations, improving robustness to rotational variance.";case"brighten":return"Brightening an image increases the intensity of all pixels, making the image appear lighter. This augmentation can simulate different lighting conditions, ensuring the model can perform well under varying brightness levels.";case"crop_imm":return"Cropping removes a portion of the image, focusing on a specific region. This augmentation can help the model learn to recognize objects even when they are partially visible or when the image is zoomed in.";default:return"Unknown augmentation type. Please provide a valid augmentation type such as grayscale, blur, fliph, flipv, huerotate, rotate90, brighten, or crop."}}(o)},t.addEventListener("change",(()=>{n.readAsDataURL(t.files[0])}))}()})();